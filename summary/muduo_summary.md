# muduo 网络库

## 简要

```shell
       1. 编写网络库的目的
              主要 C++/java 等高级语义的 socket api 没有提供更高级的封装，编写网络程序很容易出现问题，为了
              提高开发的效率以及开发的难度，以及更加方便处理并发连接．
              
       2. 线程模型
            采用 one loop per thread + thread pool 模型，每个线程最多有一个 EventLoop, 每个
            TcpConnection 必须由某个 EventLoop 管理，每个文件描述符只能由一个线程进行读写
            
       3. 基于事件的非阻塞网络编程
                由原来的 "主动调用 recv() 接受数据，　主动调用 accept() 接受新的连接，　主动调用 send()
                发送数据"　改变为　"注册一个收数据的回调，网络库收到数据就会调用我，直接把数据提供给我，
                供我消费．　注册一个接受连接的回调，网络库接受到新的连接会回调我，直接把新的连接对象传给
                我，供我使用．　需要发送数据时，只管往连接中写数据，网络库负责无阻塞得发送"
                
       4. TCP 网络编程相关的问题：　Linux 多线程服务端编程(P137)
       5.TCP 网络编程(三个半事件)
            1. 　连接的建立．　包括服务端的接受(accept) 新连接和客户端发起连接(connect)
            2. 　连接的断开．　包括主动连接(close,shutdown)和被动连接(read的字节数为 0 )
            3. 　消息的接受．　接受的处理(阻塞还是非阻塞，如何处理分包，应用层的缓冲设计)
            3.5  消息的发送．　对于低流量的服务，可以不必关心这个事件，这里发送完毕只是将数据从
            　　　　　　　　　　用户拷贝到系统的发送缓冲区，由 TCP 协议 自主得将数据发送出去，
            　　　　　　　　　　发送完毕不代表对端接受成功
            
       6. TCP half-close
            通过shutdownWrite()先关闭 "写"　方向的连接, 等对方关闭之后，在关闭本地的 "读" 方向的连接.
            而不能直接使用 close() 关闭读写连接
            
       7. TCP 分包
            在发送一个消息或一帧数据时，通过一定的处理，让接收方能从字节流中识别并截取出一个个消息．
            (1) 对于短连接(通常就发一条消息)，发送方发送完一条消息后主动关闭连接，则接收方 read() 
            　　直到为 0, 说明消息接受完毕
            (2) 长连接的 TCP 分包方法:
                    A. 消息长度固定
                    B. 使用特殊的字符或则字符串作为消息的边界
                    C. 每一条消息的头部加一个长度字段
                    D. 利用消息本身的格式来分包，例如 XML 格式的消息中 <root>  </root>　的配对，以及 JSON 格式中
                    　　{...} 的配对，解析这种消息格式通常会用到状态机
            

```

## 客户端工具

```shell
    1.netcat
        A. 实现网络客户端打印服务器响应的内容
            > nc ip port
```

## 性能测试

```shell
    1.吞吐量测试
        可以根据 ping pong 协议来测试 muduo(网络库) 在单机上的吞吐量.
        ping pong 协议是当客户端与服务端建立连接时，客户端向服务端发送一些数据，服务端则 echo 这些数据(服务端不进行
        数据的解析，只是远远本本得返回给客户端)，客户端再 echo 给服务器，这些数据像乒乓球一样来回在客户端和服务端
        传输，直到连接中断

```

## 值得一读

```shell
    1. example/asio/chat/server_thread.cc
       example/asio/chat/server_thread_efficient.cc 借 shared_ptr 实现 copy-on-write 的手法减低锁竞争
       example/asio/chat/server_thread_highperformance.cc 采用 thread local　变量，实现多线程高效转发．

```
